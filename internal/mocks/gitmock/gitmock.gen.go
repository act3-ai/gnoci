// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/act3-ai/gnoci/internal/git (interfaces: Repository)
//
// Generated by this command:
//
//	mockgen -typed -package gitmock -destination ./gitmock.gen.go github.com/act3-ai/gnoci/internal/git Repository
//

// Package gitmock is a generated GoMock package.
package gitmock

import (
	context "context"
	reflect "reflect"

	git "github.com/go-git/go-git/v5"
	config "github.com/go-git/go-git/v5/config"
	plumbing "github.com/go-git/go-git/v5/plumbing"
	object "github.com/go-git/go-git/v5/plumbing/object"
	storer "github.com/go-git/go-git/v5/plumbing/storer"
	storage "github.com/go-git/go-git/v5/storage"
	gomock "go.uber.org/mock/gomock"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
	ctrl     *gomock.Controller
	recorder *MockRepositoryMockRecorder
	isgomock struct{}
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
	mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository {
	mock := &MockRepository{ctrl: ctrl}
	mock.recorder = &MockRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder {
	return m.recorder
}

// BlobObject mocks base method.
func (m *MockRepository) BlobObject(h plumbing.Hash) (*object.Blob, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BlobObject", h)
	ret0, _ := ret[0].(*object.Blob)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BlobObject indicates an expected call of BlobObject.
func (mr *MockRepositoryMockRecorder) BlobObject(h any) *MockRepositoryBlobObjectCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BlobObject", reflect.TypeOf((*MockRepository)(nil).BlobObject), h)
	return &MockRepositoryBlobObjectCall{Call: call}
}

// MockRepositoryBlobObjectCall wrap *gomock.Call
type MockRepositoryBlobObjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryBlobObjectCall) Return(arg0 *object.Blob, arg1 error) *MockRepositoryBlobObjectCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryBlobObjectCall) Do(f func(plumbing.Hash) (*object.Blob, error)) *MockRepositoryBlobObjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryBlobObjectCall) DoAndReturn(f func(plumbing.Hash) (*object.Blob, error)) *MockRepositoryBlobObjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BlobObjects mocks base method.
func (m *MockRepository) BlobObjects() (*object.BlobIter, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BlobObjects")
	ret0, _ := ret[0].(*object.BlobIter)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BlobObjects indicates an expected call of BlobObjects.
func (mr *MockRepositoryMockRecorder) BlobObjects() *MockRepositoryBlobObjectsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BlobObjects", reflect.TypeOf((*MockRepository)(nil).BlobObjects))
	return &MockRepositoryBlobObjectsCall{Call: call}
}

// MockRepositoryBlobObjectsCall wrap *gomock.Call
type MockRepositoryBlobObjectsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryBlobObjectsCall) Return(arg0 *object.BlobIter, arg1 error) *MockRepositoryBlobObjectsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryBlobObjectsCall) Do(f func() (*object.BlobIter, error)) *MockRepositoryBlobObjectsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryBlobObjectsCall) DoAndReturn(f func() (*object.BlobIter, error)) *MockRepositoryBlobObjectsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Branch mocks base method.
func (m *MockRepository) Branch(name string) (*config.Branch, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Branch", name)
	ret0, _ := ret[0].(*config.Branch)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Branch indicates an expected call of Branch.
func (mr *MockRepositoryMockRecorder) Branch(name any) *MockRepositoryBranchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Branch", reflect.TypeOf((*MockRepository)(nil).Branch), name)
	return &MockRepositoryBranchCall{Call: call}
}

// MockRepositoryBranchCall wrap *gomock.Call
type MockRepositoryBranchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryBranchCall) Return(arg0 *config.Branch, arg1 error) *MockRepositoryBranchCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryBranchCall) Do(f func(string) (*config.Branch, error)) *MockRepositoryBranchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryBranchCall) DoAndReturn(f func(string) (*config.Branch, error)) *MockRepositoryBranchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Branches mocks base method.
func (m *MockRepository) Branches() (storer.ReferenceIter, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Branches")
	ret0, _ := ret[0].(storer.ReferenceIter)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Branches indicates an expected call of Branches.
func (mr *MockRepositoryMockRecorder) Branches() *MockRepositoryBranchesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Branches", reflect.TypeOf((*MockRepository)(nil).Branches))
	return &MockRepositoryBranchesCall{Call: call}
}

// MockRepositoryBranchesCall wrap *gomock.Call
type MockRepositoryBranchesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryBranchesCall) Return(arg0 storer.ReferenceIter, arg1 error) *MockRepositoryBranchesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryBranchesCall) Do(f func() (storer.ReferenceIter, error)) *MockRepositoryBranchesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryBranchesCall) DoAndReturn(f func() (storer.ReferenceIter, error)) *MockRepositoryBranchesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CommitObject mocks base method.
func (m *MockRepository) CommitObject(h plumbing.Hash) (*object.Commit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CommitObject", h)
	ret0, _ := ret[0].(*object.Commit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CommitObject indicates an expected call of CommitObject.
func (mr *MockRepositoryMockRecorder) CommitObject(h any) *MockRepositoryCommitObjectCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CommitObject", reflect.TypeOf((*MockRepository)(nil).CommitObject), h)
	return &MockRepositoryCommitObjectCall{Call: call}
}

// MockRepositoryCommitObjectCall wrap *gomock.Call
type MockRepositoryCommitObjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryCommitObjectCall) Return(arg0 *object.Commit, arg1 error) *MockRepositoryCommitObjectCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryCommitObjectCall) Do(f func(plumbing.Hash) (*object.Commit, error)) *MockRepositoryCommitObjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryCommitObjectCall) DoAndReturn(f func(plumbing.Hash) (*object.Commit, error)) *MockRepositoryCommitObjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CommitObjects mocks base method.
func (m *MockRepository) CommitObjects() (object.CommitIter, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CommitObjects")
	ret0, _ := ret[0].(object.CommitIter)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CommitObjects indicates an expected call of CommitObjects.
func (mr *MockRepositoryMockRecorder) CommitObjects() *MockRepositoryCommitObjectsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CommitObjects", reflect.TypeOf((*MockRepository)(nil).CommitObjects))
	return &MockRepositoryCommitObjectsCall{Call: call}
}

// MockRepositoryCommitObjectsCall wrap *gomock.Call
type MockRepositoryCommitObjectsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryCommitObjectsCall) Return(arg0 object.CommitIter, arg1 error) *MockRepositoryCommitObjectsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryCommitObjectsCall) Do(f func() (object.CommitIter, error)) *MockRepositoryCommitObjectsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryCommitObjectsCall) DoAndReturn(f func() (object.CommitIter, error)) *MockRepositoryCommitObjectsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Config mocks base method.
func (m *MockRepository) Config() (*config.Config, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Config")
	ret0, _ := ret[0].(*config.Config)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Config indicates an expected call of Config.
func (mr *MockRepositoryMockRecorder) Config() *MockRepositoryConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Config", reflect.TypeOf((*MockRepository)(nil).Config))
	return &MockRepositoryConfigCall{Call: call}
}

// MockRepositoryConfigCall wrap *gomock.Call
type MockRepositoryConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryConfigCall) Return(arg0 *config.Config, arg1 error) *MockRepositoryConfigCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryConfigCall) Do(f func() (*config.Config, error)) *MockRepositoryConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryConfigCall) DoAndReturn(f func() (*config.Config, error)) *MockRepositoryConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ConfigScoped mocks base method.
func (m *MockRepository) ConfigScoped(scope config.Scope) (*config.Config, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ConfigScoped", scope)
	ret0, _ := ret[0].(*config.Config)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ConfigScoped indicates an expected call of ConfigScoped.
func (mr *MockRepositoryMockRecorder) ConfigScoped(scope any) *MockRepositoryConfigScopedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConfigScoped", reflect.TypeOf((*MockRepository)(nil).ConfigScoped), scope)
	return &MockRepositoryConfigScopedCall{Call: call}
}

// MockRepositoryConfigScopedCall wrap *gomock.Call
type MockRepositoryConfigScopedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryConfigScopedCall) Return(arg0 *config.Config, arg1 error) *MockRepositoryConfigScopedCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryConfigScopedCall) Do(f func(config.Scope) (*config.Config, error)) *MockRepositoryConfigScopedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryConfigScopedCall) DoAndReturn(f func(config.Scope) (*config.Config, error)) *MockRepositoryConfigScopedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateBranch mocks base method.
func (m *MockRepository) CreateBranch(c *config.Branch) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateBranch", c)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateBranch indicates an expected call of CreateBranch.
func (mr *MockRepositoryMockRecorder) CreateBranch(c any) *MockRepositoryCreateBranchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateBranch", reflect.TypeOf((*MockRepository)(nil).CreateBranch), c)
	return &MockRepositoryCreateBranchCall{Call: call}
}

// MockRepositoryCreateBranchCall wrap *gomock.Call
type MockRepositoryCreateBranchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c_2 *MockRepositoryCreateBranchCall) Return(arg0 error) *MockRepositoryCreateBranchCall {
	c_2.Call = c_2.Call.Return(arg0)
	return c_2
}

// Do rewrite *gomock.Call.Do
func (c_2 *MockRepositoryCreateBranchCall) Do(f func(*config.Branch) error) *MockRepositoryCreateBranchCall {
	c_2.Call = c_2.Call.Do(f)
	return c_2
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c_2 *MockRepositoryCreateBranchCall) DoAndReturn(f func(*config.Branch) error) *MockRepositoryCreateBranchCall {
	c_2.Call = c_2.Call.DoAndReturn(f)
	return c_2
}

// CreateRemote mocks base method.
func (m *MockRepository) CreateRemote(c *config.RemoteConfig) (*git.Remote, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateRemote", c)
	ret0, _ := ret[0].(*git.Remote)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateRemote indicates an expected call of CreateRemote.
func (mr *MockRepositoryMockRecorder) CreateRemote(c any) *MockRepositoryCreateRemoteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateRemote", reflect.TypeOf((*MockRepository)(nil).CreateRemote), c)
	return &MockRepositoryCreateRemoteCall{Call: call}
}

// MockRepositoryCreateRemoteCall wrap *gomock.Call
type MockRepositoryCreateRemoteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c_2 *MockRepositoryCreateRemoteCall) Return(arg0 *git.Remote, arg1 error) *MockRepositoryCreateRemoteCall {
	c_2.Call = c_2.Call.Return(arg0, arg1)
	return c_2
}

// Do rewrite *gomock.Call.Do
func (c_2 *MockRepositoryCreateRemoteCall) Do(f func(*config.RemoteConfig) (*git.Remote, error)) *MockRepositoryCreateRemoteCall {
	c_2.Call = c_2.Call.Do(f)
	return c_2
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c_2 *MockRepositoryCreateRemoteCall) DoAndReturn(f func(*config.RemoteConfig) (*git.Remote, error)) *MockRepositoryCreateRemoteCall {
	c_2.Call = c_2.Call.DoAndReturn(f)
	return c_2
}

// CreateRemoteAnonymous mocks base method.
func (m *MockRepository) CreateRemoteAnonymous(c *config.RemoteConfig) (*git.Remote, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateRemoteAnonymous", c)
	ret0, _ := ret[0].(*git.Remote)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateRemoteAnonymous indicates an expected call of CreateRemoteAnonymous.
func (mr *MockRepositoryMockRecorder) CreateRemoteAnonymous(c any) *MockRepositoryCreateRemoteAnonymousCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateRemoteAnonymous", reflect.TypeOf((*MockRepository)(nil).CreateRemoteAnonymous), c)
	return &MockRepositoryCreateRemoteAnonymousCall{Call: call}
}

// MockRepositoryCreateRemoteAnonymousCall wrap *gomock.Call
type MockRepositoryCreateRemoteAnonymousCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c_2 *MockRepositoryCreateRemoteAnonymousCall) Return(arg0 *git.Remote, arg1 error) *MockRepositoryCreateRemoteAnonymousCall {
	c_2.Call = c_2.Call.Return(arg0, arg1)
	return c_2
}

// Do rewrite *gomock.Call.Do
func (c_2 *MockRepositoryCreateRemoteAnonymousCall) Do(f func(*config.RemoteConfig) (*git.Remote, error)) *MockRepositoryCreateRemoteAnonymousCall {
	c_2.Call = c_2.Call.Do(f)
	return c_2
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c_2 *MockRepositoryCreateRemoteAnonymousCall) DoAndReturn(f func(*config.RemoteConfig) (*git.Remote, error)) *MockRepositoryCreateRemoteAnonymousCall {
	c_2.Call = c_2.Call.DoAndReturn(f)
	return c_2
}

// CreateTag mocks base method.
func (m *MockRepository) CreateTag(name string, hash plumbing.Hash, opts *git.CreateTagOptions) (*plumbing.Reference, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTag", name, hash, opts)
	ret0, _ := ret[0].(*plumbing.Reference)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateTag indicates an expected call of CreateTag.
func (mr *MockRepositoryMockRecorder) CreateTag(name, hash, opts any) *MockRepositoryCreateTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTag", reflect.TypeOf((*MockRepository)(nil).CreateTag), name, hash, opts)
	return &MockRepositoryCreateTagCall{Call: call}
}

// MockRepositoryCreateTagCall wrap *gomock.Call
type MockRepositoryCreateTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryCreateTagCall) Return(arg0 *plumbing.Reference, arg1 error) *MockRepositoryCreateTagCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryCreateTagCall) Do(f func(string, plumbing.Hash, *git.CreateTagOptions) (*plumbing.Reference, error)) *MockRepositoryCreateTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryCreateTagCall) DoAndReturn(f func(string, plumbing.Hash, *git.CreateTagOptions) (*plumbing.Reference, error)) *MockRepositoryCreateTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteBranch mocks base method.
func (m *MockRepository) DeleteBranch(name string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteBranch", name)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteBranch indicates an expected call of DeleteBranch.
func (mr *MockRepositoryMockRecorder) DeleteBranch(name any) *MockRepositoryDeleteBranchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteBranch", reflect.TypeOf((*MockRepository)(nil).DeleteBranch), name)
	return &MockRepositoryDeleteBranchCall{Call: call}
}

// MockRepositoryDeleteBranchCall wrap *gomock.Call
type MockRepositoryDeleteBranchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryDeleteBranchCall) Return(arg0 error) *MockRepositoryDeleteBranchCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryDeleteBranchCall) Do(f func(string) error) *MockRepositoryDeleteBranchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryDeleteBranchCall) DoAndReturn(f func(string) error) *MockRepositoryDeleteBranchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteObject mocks base method.
func (m *MockRepository) DeleteObject(hash plumbing.Hash) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteObject", hash)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteObject indicates an expected call of DeleteObject.
func (mr *MockRepositoryMockRecorder) DeleteObject(hash any) *MockRepositoryDeleteObjectCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteObject", reflect.TypeOf((*MockRepository)(nil).DeleteObject), hash)
	return &MockRepositoryDeleteObjectCall{Call: call}
}

// MockRepositoryDeleteObjectCall wrap *gomock.Call
type MockRepositoryDeleteObjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryDeleteObjectCall) Return(arg0 error) *MockRepositoryDeleteObjectCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryDeleteObjectCall) Do(f func(plumbing.Hash) error) *MockRepositoryDeleteObjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryDeleteObjectCall) DoAndReturn(f func(plumbing.Hash) error) *MockRepositoryDeleteObjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteRemote mocks base method.
func (m *MockRepository) DeleteRemote(name string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteRemote", name)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteRemote indicates an expected call of DeleteRemote.
func (mr *MockRepositoryMockRecorder) DeleteRemote(name any) *MockRepositoryDeleteRemoteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteRemote", reflect.TypeOf((*MockRepository)(nil).DeleteRemote), name)
	return &MockRepositoryDeleteRemoteCall{Call: call}
}

// MockRepositoryDeleteRemoteCall wrap *gomock.Call
type MockRepositoryDeleteRemoteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryDeleteRemoteCall) Return(arg0 error) *MockRepositoryDeleteRemoteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryDeleteRemoteCall) Do(f func(string) error) *MockRepositoryDeleteRemoteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryDeleteRemoteCall) DoAndReturn(f func(string) error) *MockRepositoryDeleteRemoteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteTag mocks base method.
func (m *MockRepository) DeleteTag(name string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteTag", name)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteTag indicates an expected call of DeleteTag.
func (mr *MockRepositoryMockRecorder) DeleteTag(name any) *MockRepositoryDeleteTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteTag", reflect.TypeOf((*MockRepository)(nil).DeleteTag), name)
	return &MockRepositoryDeleteTagCall{Call: call}
}

// MockRepositoryDeleteTagCall wrap *gomock.Call
type MockRepositoryDeleteTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryDeleteTagCall) Return(arg0 error) *MockRepositoryDeleteTagCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryDeleteTagCall) Do(f func(string) error) *MockRepositoryDeleteTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryDeleteTagCall) DoAndReturn(f func(string) error) *MockRepositoryDeleteTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Fetch mocks base method.
func (m *MockRepository) Fetch(o *git.FetchOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Fetch", o)
	ret0, _ := ret[0].(error)
	return ret0
}

// Fetch indicates an expected call of Fetch.
func (mr *MockRepositoryMockRecorder) Fetch(o any) *MockRepositoryFetchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fetch", reflect.TypeOf((*MockRepository)(nil).Fetch), o)
	return &MockRepositoryFetchCall{Call: call}
}

// MockRepositoryFetchCall wrap *gomock.Call
type MockRepositoryFetchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryFetchCall) Return(arg0 error) *MockRepositoryFetchCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryFetchCall) Do(f func(*git.FetchOptions) error) *MockRepositoryFetchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryFetchCall) DoAndReturn(f func(*git.FetchOptions) error) *MockRepositoryFetchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FetchContext mocks base method.
func (m *MockRepository) FetchContext(ctx context.Context, o *git.FetchOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchContext", ctx, o)
	ret0, _ := ret[0].(error)
	return ret0
}

// FetchContext indicates an expected call of FetchContext.
func (mr *MockRepositoryMockRecorder) FetchContext(ctx, o any) *MockRepositoryFetchContextCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchContext", reflect.TypeOf((*MockRepository)(nil).FetchContext), ctx, o)
	return &MockRepositoryFetchContextCall{Call: call}
}

// MockRepositoryFetchContextCall wrap *gomock.Call
type MockRepositoryFetchContextCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryFetchContextCall) Return(arg0 error) *MockRepositoryFetchContextCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryFetchContextCall) Do(f func(context.Context, *git.FetchOptions) error) *MockRepositoryFetchContextCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryFetchContextCall) DoAndReturn(f func(context.Context, *git.FetchOptions) error) *MockRepositoryFetchContextCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Grep mocks base method.
func (m *MockRepository) Grep(opts *git.GrepOptions) ([]git.GrepResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Grep", opts)
	ret0, _ := ret[0].([]git.GrepResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Grep indicates an expected call of Grep.
func (mr *MockRepositoryMockRecorder) Grep(opts any) *MockRepositoryGrepCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Grep", reflect.TypeOf((*MockRepository)(nil).Grep), opts)
	return &MockRepositoryGrepCall{Call: call}
}

// MockRepositoryGrepCall wrap *gomock.Call
type MockRepositoryGrepCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryGrepCall) Return(arg0 []git.GrepResult, arg1 error) *MockRepositoryGrepCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryGrepCall) Do(f func(*git.GrepOptions) ([]git.GrepResult, error)) *MockRepositoryGrepCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryGrepCall) DoAndReturn(f func(*git.GrepOptions) ([]git.GrepResult, error)) *MockRepositoryGrepCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Head mocks base method.
func (m *MockRepository) Head() (*plumbing.Reference, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Head")
	ret0, _ := ret[0].(*plumbing.Reference)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Head indicates an expected call of Head.
func (mr *MockRepositoryMockRecorder) Head() *MockRepositoryHeadCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Head", reflect.TypeOf((*MockRepository)(nil).Head))
	return &MockRepositoryHeadCall{Call: call}
}

// MockRepositoryHeadCall wrap *gomock.Call
type MockRepositoryHeadCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryHeadCall) Return(arg0 *plumbing.Reference, arg1 error) *MockRepositoryHeadCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryHeadCall) Do(f func() (*plumbing.Reference, error)) *MockRepositoryHeadCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryHeadCall) DoAndReturn(f func() (*plumbing.Reference, error)) *MockRepositoryHeadCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Log mocks base method.
func (m *MockRepository) Log(o *git.LogOptions) (object.CommitIter, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Log", o)
	ret0, _ := ret[0].(object.CommitIter)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Log indicates an expected call of Log.
func (mr *MockRepositoryMockRecorder) Log(o any) *MockRepositoryLogCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Log", reflect.TypeOf((*MockRepository)(nil).Log), o)
	return &MockRepositoryLogCall{Call: call}
}

// MockRepositoryLogCall wrap *gomock.Call
type MockRepositoryLogCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryLogCall) Return(arg0 object.CommitIter, arg1 error) *MockRepositoryLogCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryLogCall) Do(f func(*git.LogOptions) (object.CommitIter, error)) *MockRepositoryLogCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryLogCall) DoAndReturn(f func(*git.LogOptions) (object.CommitIter, error)) *MockRepositoryLogCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Merge mocks base method.
func (m *MockRepository) Merge(ref plumbing.Reference, opts git.MergeOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Merge", ref, opts)
	ret0, _ := ret[0].(error)
	return ret0
}

// Merge indicates an expected call of Merge.
func (mr *MockRepositoryMockRecorder) Merge(ref, opts any) *MockRepositoryMergeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Merge", reflect.TypeOf((*MockRepository)(nil).Merge), ref, opts)
	return &MockRepositoryMergeCall{Call: call}
}

// MockRepositoryMergeCall wrap *gomock.Call
type MockRepositoryMergeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryMergeCall) Return(arg0 error) *MockRepositoryMergeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryMergeCall) Do(f func(plumbing.Reference, git.MergeOptions) error) *MockRepositoryMergeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryMergeCall) DoAndReturn(f func(plumbing.Reference, git.MergeOptions) error) *MockRepositoryMergeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Notes mocks base method.
func (m *MockRepository) Notes() (storer.ReferenceIter, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Notes")
	ret0, _ := ret[0].(storer.ReferenceIter)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Notes indicates an expected call of Notes.
func (mr *MockRepositoryMockRecorder) Notes() *MockRepositoryNotesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Notes", reflect.TypeOf((*MockRepository)(nil).Notes))
	return &MockRepositoryNotesCall{Call: call}
}

// MockRepositoryNotesCall wrap *gomock.Call
type MockRepositoryNotesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryNotesCall) Return(arg0 storer.ReferenceIter, arg1 error) *MockRepositoryNotesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryNotesCall) Do(f func() (storer.ReferenceIter, error)) *MockRepositoryNotesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryNotesCall) DoAndReturn(f func() (storer.ReferenceIter, error)) *MockRepositoryNotesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Object mocks base method.
func (m *MockRepository) Object(t plumbing.ObjectType, h plumbing.Hash) (object.Object, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Object", t, h)
	ret0, _ := ret[0].(object.Object)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Object indicates an expected call of Object.
func (mr *MockRepositoryMockRecorder) Object(t, h any) *MockRepositoryObjectCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Object", reflect.TypeOf((*MockRepository)(nil).Object), t, h)
	return &MockRepositoryObjectCall{Call: call}
}

// MockRepositoryObjectCall wrap *gomock.Call
type MockRepositoryObjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryObjectCall) Return(arg0 object.Object, arg1 error) *MockRepositoryObjectCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryObjectCall) Do(f func(plumbing.ObjectType, plumbing.Hash) (object.Object, error)) *MockRepositoryObjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryObjectCall) DoAndReturn(f func(plumbing.ObjectType, plumbing.Hash) (object.Object, error)) *MockRepositoryObjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Objects mocks base method.
func (m *MockRepository) Objects() (*object.ObjectIter, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Objects")
	ret0, _ := ret[0].(*object.ObjectIter)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Objects indicates an expected call of Objects.
func (mr *MockRepositoryMockRecorder) Objects() *MockRepositoryObjectsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Objects", reflect.TypeOf((*MockRepository)(nil).Objects))
	return &MockRepositoryObjectsCall{Call: call}
}

// MockRepositoryObjectsCall wrap *gomock.Call
type MockRepositoryObjectsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryObjectsCall) Return(arg0 *object.ObjectIter, arg1 error) *MockRepositoryObjectsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryObjectsCall) Do(f func() (*object.ObjectIter, error)) *MockRepositoryObjectsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryObjectsCall) DoAndReturn(f func() (*object.ObjectIter, error)) *MockRepositoryObjectsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Prune mocks base method.
func (m *MockRepository) Prune(opt git.PruneOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Prune", opt)
	ret0, _ := ret[0].(error)
	return ret0
}

// Prune indicates an expected call of Prune.
func (mr *MockRepositoryMockRecorder) Prune(opt any) *MockRepositoryPruneCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Prune", reflect.TypeOf((*MockRepository)(nil).Prune), opt)
	return &MockRepositoryPruneCall{Call: call}
}

// MockRepositoryPruneCall wrap *gomock.Call
type MockRepositoryPruneCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryPruneCall) Return(arg0 error) *MockRepositoryPruneCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryPruneCall) Do(f func(git.PruneOptions) error) *MockRepositoryPruneCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryPruneCall) DoAndReturn(f func(git.PruneOptions) error) *MockRepositoryPruneCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Push mocks base method.
func (m *MockRepository) Push(o *git.PushOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Push", o)
	ret0, _ := ret[0].(error)
	return ret0
}

// Push indicates an expected call of Push.
func (mr *MockRepositoryMockRecorder) Push(o any) *MockRepositoryPushCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Push", reflect.TypeOf((*MockRepository)(nil).Push), o)
	return &MockRepositoryPushCall{Call: call}
}

// MockRepositoryPushCall wrap *gomock.Call
type MockRepositoryPushCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryPushCall) Return(arg0 error) *MockRepositoryPushCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryPushCall) Do(f func(*git.PushOptions) error) *MockRepositoryPushCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryPushCall) DoAndReturn(f func(*git.PushOptions) error) *MockRepositoryPushCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PushContext mocks base method.
func (m *MockRepository) PushContext(ctx context.Context, o *git.PushOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PushContext", ctx, o)
	ret0, _ := ret[0].(error)
	return ret0
}

// PushContext indicates an expected call of PushContext.
func (mr *MockRepositoryMockRecorder) PushContext(ctx, o any) *MockRepositoryPushContextCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PushContext", reflect.TypeOf((*MockRepository)(nil).PushContext), ctx, o)
	return &MockRepositoryPushContextCall{Call: call}
}

// MockRepositoryPushContextCall wrap *gomock.Call
type MockRepositoryPushContextCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryPushContextCall) Return(arg0 error) *MockRepositoryPushContextCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryPushContextCall) Do(f func(context.Context, *git.PushOptions) error) *MockRepositoryPushContextCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryPushContextCall) DoAndReturn(f func(context.Context, *git.PushOptions) error) *MockRepositoryPushContextCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Reference mocks base method.
func (m *MockRepository) Reference(name plumbing.ReferenceName, resolved bool) (*plumbing.Reference, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Reference", name, resolved)
	ret0, _ := ret[0].(*plumbing.Reference)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Reference indicates an expected call of Reference.
func (mr *MockRepositoryMockRecorder) Reference(name, resolved any) *MockRepositoryReferenceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Reference", reflect.TypeOf((*MockRepository)(nil).Reference), name, resolved)
	return &MockRepositoryReferenceCall{Call: call}
}

// MockRepositoryReferenceCall wrap *gomock.Call
type MockRepositoryReferenceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryReferenceCall) Return(arg0 *plumbing.Reference, arg1 error) *MockRepositoryReferenceCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryReferenceCall) Do(f func(plumbing.ReferenceName, bool) (*plumbing.Reference, error)) *MockRepositoryReferenceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryReferenceCall) DoAndReturn(f func(plumbing.ReferenceName, bool) (*plumbing.Reference, error)) *MockRepositoryReferenceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// References mocks base method.
func (m *MockRepository) References() (storer.ReferenceIter, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "References")
	ret0, _ := ret[0].(storer.ReferenceIter)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// References indicates an expected call of References.
func (mr *MockRepositoryMockRecorder) References() *MockRepositoryReferencesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "References", reflect.TypeOf((*MockRepository)(nil).References))
	return &MockRepositoryReferencesCall{Call: call}
}

// MockRepositoryReferencesCall wrap *gomock.Call
type MockRepositoryReferencesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryReferencesCall) Return(arg0 storer.ReferenceIter, arg1 error) *MockRepositoryReferencesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryReferencesCall) Do(f func() (storer.ReferenceIter, error)) *MockRepositoryReferencesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryReferencesCall) DoAndReturn(f func() (storer.ReferenceIter, error)) *MockRepositoryReferencesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Remote mocks base method.
func (m *MockRepository) Remote(name string) (*git.Remote, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Remote", name)
	ret0, _ := ret[0].(*git.Remote)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Remote indicates an expected call of Remote.
func (mr *MockRepositoryMockRecorder) Remote(name any) *MockRepositoryRemoteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Remote", reflect.TypeOf((*MockRepository)(nil).Remote), name)
	return &MockRepositoryRemoteCall{Call: call}
}

// MockRepositoryRemoteCall wrap *gomock.Call
type MockRepositoryRemoteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryRemoteCall) Return(arg0 *git.Remote, arg1 error) *MockRepositoryRemoteCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryRemoteCall) Do(f func(string) (*git.Remote, error)) *MockRepositoryRemoteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryRemoteCall) DoAndReturn(f func(string) (*git.Remote, error)) *MockRepositoryRemoteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Remotes mocks base method.
func (m *MockRepository) Remotes() ([]*git.Remote, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Remotes")
	ret0, _ := ret[0].([]*git.Remote)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Remotes indicates an expected call of Remotes.
func (mr *MockRepositoryMockRecorder) Remotes() *MockRepositoryRemotesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Remotes", reflect.TypeOf((*MockRepository)(nil).Remotes))
	return &MockRepositoryRemotesCall{Call: call}
}

// MockRepositoryRemotesCall wrap *gomock.Call
type MockRepositoryRemotesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryRemotesCall) Return(arg0 []*git.Remote, arg1 error) *MockRepositoryRemotesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryRemotesCall) Do(f func() ([]*git.Remote, error)) *MockRepositoryRemotesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryRemotesCall) DoAndReturn(f func() ([]*git.Remote, error)) *MockRepositoryRemotesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RepackObjects mocks base method.
func (m *MockRepository) RepackObjects(cfg *git.RepackConfig) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RepackObjects", cfg)
	ret0, _ := ret[0].(error)
	return ret0
}

// RepackObjects indicates an expected call of RepackObjects.
func (mr *MockRepositoryMockRecorder) RepackObjects(cfg any) *MockRepositoryRepackObjectsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RepackObjects", reflect.TypeOf((*MockRepository)(nil).RepackObjects), cfg)
	return &MockRepositoryRepackObjectsCall{Call: call}
}

// MockRepositoryRepackObjectsCall wrap *gomock.Call
type MockRepositoryRepackObjectsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryRepackObjectsCall) Return(err error) *MockRepositoryRepackObjectsCall {
	c.Call = c.Call.Return(err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryRepackObjectsCall) Do(f func(*git.RepackConfig) error) *MockRepositoryRepackObjectsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryRepackObjectsCall) DoAndReturn(f func(*git.RepackConfig) error) *MockRepositoryRepackObjectsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ResolveRevision mocks base method.
func (m *MockRepository) ResolveRevision(in plumbing.Revision) (*plumbing.Hash, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResolveRevision", in)
	ret0, _ := ret[0].(*plumbing.Hash)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ResolveRevision indicates an expected call of ResolveRevision.
func (mr *MockRepositoryMockRecorder) ResolveRevision(in any) *MockRepositoryResolveRevisionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResolveRevision", reflect.TypeOf((*MockRepository)(nil).ResolveRevision), in)
	return &MockRepositoryResolveRevisionCall{Call: call}
}

// MockRepositoryResolveRevisionCall wrap *gomock.Call
type MockRepositoryResolveRevisionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryResolveRevisionCall) Return(arg0 *plumbing.Hash, arg1 error) *MockRepositoryResolveRevisionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryResolveRevisionCall) Do(f func(plumbing.Revision) (*plumbing.Hash, error)) *MockRepositoryResolveRevisionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryResolveRevisionCall) DoAndReturn(f func(plumbing.Revision) (*plumbing.Hash, error)) *MockRepositoryResolveRevisionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetConfig mocks base method.
func (m *MockRepository) SetConfig(cfg *config.Config) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetConfig", cfg)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetConfig indicates an expected call of SetConfig.
func (mr *MockRepositoryMockRecorder) SetConfig(cfg any) *MockRepositorySetConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetConfig", reflect.TypeOf((*MockRepository)(nil).SetConfig), cfg)
	return &MockRepositorySetConfigCall{Call: call}
}

// MockRepositorySetConfigCall wrap *gomock.Call
type MockRepositorySetConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositorySetConfigCall) Return(arg0 error) *MockRepositorySetConfigCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositorySetConfigCall) Do(f func(*config.Config) error) *MockRepositorySetConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositorySetConfigCall) DoAndReturn(f func(*config.Config) error) *MockRepositorySetConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Storer mocks base method.
func (m *MockRepository) Storer() storage.Storer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Storer")
	ret0, _ := ret[0].(storage.Storer)
	return ret0
}

// Storer indicates an expected call of Storer.
func (mr *MockRepositoryMockRecorder) Storer() *MockRepositoryStorerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Storer", reflect.TypeOf((*MockRepository)(nil).Storer))
	return &MockRepositoryStorerCall{Call: call}
}

// MockRepositoryStorerCall wrap *gomock.Call
type MockRepositoryStorerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryStorerCall) Return(arg0 storage.Storer) *MockRepositoryStorerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryStorerCall) Do(f func() storage.Storer) *MockRepositoryStorerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryStorerCall) DoAndReturn(f func() storage.Storer) *MockRepositoryStorerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Tag mocks base method.
func (m *MockRepository) Tag(name string) (*plumbing.Reference, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Tag", name)
	ret0, _ := ret[0].(*plumbing.Reference)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Tag indicates an expected call of Tag.
func (mr *MockRepositoryMockRecorder) Tag(name any) *MockRepositoryTagCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Tag", reflect.TypeOf((*MockRepository)(nil).Tag), name)
	return &MockRepositoryTagCall{Call: call}
}

// MockRepositoryTagCall wrap *gomock.Call
type MockRepositoryTagCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryTagCall) Return(arg0 *plumbing.Reference, arg1 error) *MockRepositoryTagCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryTagCall) Do(f func(string) (*plumbing.Reference, error)) *MockRepositoryTagCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryTagCall) DoAndReturn(f func(string) (*plumbing.Reference, error)) *MockRepositoryTagCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TagObject mocks base method.
func (m *MockRepository) TagObject(h plumbing.Hash) (*object.Tag, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TagObject", h)
	ret0, _ := ret[0].(*object.Tag)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TagObject indicates an expected call of TagObject.
func (mr *MockRepositoryMockRecorder) TagObject(h any) *MockRepositoryTagObjectCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TagObject", reflect.TypeOf((*MockRepository)(nil).TagObject), h)
	return &MockRepositoryTagObjectCall{Call: call}
}

// MockRepositoryTagObjectCall wrap *gomock.Call
type MockRepositoryTagObjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryTagObjectCall) Return(arg0 *object.Tag, arg1 error) *MockRepositoryTagObjectCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryTagObjectCall) Do(f func(plumbing.Hash) (*object.Tag, error)) *MockRepositoryTagObjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryTagObjectCall) DoAndReturn(f func(plumbing.Hash) (*object.Tag, error)) *MockRepositoryTagObjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TagObjects mocks base method.
func (m *MockRepository) TagObjects() (*object.TagIter, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TagObjects")
	ret0, _ := ret[0].(*object.TagIter)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TagObjects indicates an expected call of TagObjects.
func (mr *MockRepositoryMockRecorder) TagObjects() *MockRepositoryTagObjectsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TagObjects", reflect.TypeOf((*MockRepository)(nil).TagObjects))
	return &MockRepositoryTagObjectsCall{Call: call}
}

// MockRepositoryTagObjectsCall wrap *gomock.Call
type MockRepositoryTagObjectsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryTagObjectsCall) Return(arg0 *object.TagIter, arg1 error) *MockRepositoryTagObjectsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryTagObjectsCall) Do(f func() (*object.TagIter, error)) *MockRepositoryTagObjectsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryTagObjectsCall) DoAndReturn(f func() (*object.TagIter, error)) *MockRepositoryTagObjectsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Tags mocks base method.
func (m *MockRepository) Tags() (storer.ReferenceIter, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Tags")
	ret0, _ := ret[0].(storer.ReferenceIter)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Tags indicates an expected call of Tags.
func (mr *MockRepositoryMockRecorder) Tags() *MockRepositoryTagsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Tags", reflect.TypeOf((*MockRepository)(nil).Tags))
	return &MockRepositoryTagsCall{Call: call}
}

// MockRepositoryTagsCall wrap *gomock.Call
type MockRepositoryTagsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryTagsCall) Return(arg0 storer.ReferenceIter, arg1 error) *MockRepositoryTagsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryTagsCall) Do(f func() (storer.ReferenceIter, error)) *MockRepositoryTagsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryTagsCall) DoAndReturn(f func() (storer.ReferenceIter, error)) *MockRepositoryTagsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TreeObject mocks base method.
func (m *MockRepository) TreeObject(h plumbing.Hash) (*object.Tree, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TreeObject", h)
	ret0, _ := ret[0].(*object.Tree)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TreeObject indicates an expected call of TreeObject.
func (mr *MockRepositoryMockRecorder) TreeObject(h any) *MockRepositoryTreeObjectCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TreeObject", reflect.TypeOf((*MockRepository)(nil).TreeObject), h)
	return &MockRepositoryTreeObjectCall{Call: call}
}

// MockRepositoryTreeObjectCall wrap *gomock.Call
type MockRepositoryTreeObjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryTreeObjectCall) Return(arg0 *object.Tree, arg1 error) *MockRepositoryTreeObjectCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryTreeObjectCall) Do(f func(plumbing.Hash) (*object.Tree, error)) *MockRepositoryTreeObjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryTreeObjectCall) DoAndReturn(f func(plumbing.Hash) (*object.Tree, error)) *MockRepositoryTreeObjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TreeObjects mocks base method.
func (m *MockRepository) TreeObjects() (*object.TreeIter, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TreeObjects")
	ret0, _ := ret[0].(*object.TreeIter)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TreeObjects indicates an expected call of TreeObjects.
func (mr *MockRepositoryMockRecorder) TreeObjects() *MockRepositoryTreeObjectsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TreeObjects", reflect.TypeOf((*MockRepository)(nil).TreeObjects))
	return &MockRepositoryTreeObjectsCall{Call: call}
}

// MockRepositoryTreeObjectsCall wrap *gomock.Call
type MockRepositoryTreeObjectsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryTreeObjectsCall) Return(arg0 *object.TreeIter, arg1 error) *MockRepositoryTreeObjectsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryTreeObjectsCall) Do(f func() (*object.TreeIter, error)) *MockRepositoryTreeObjectsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryTreeObjectsCall) DoAndReturn(f func() (*object.TreeIter, error)) *MockRepositoryTreeObjectsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Worktree mocks base method.
func (m *MockRepository) Worktree() (*git.Worktree, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Worktree")
	ret0, _ := ret[0].(*git.Worktree)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Worktree indicates an expected call of Worktree.
func (mr *MockRepositoryMockRecorder) Worktree() *MockRepositoryWorktreeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Worktree", reflect.TypeOf((*MockRepository)(nil).Worktree))
	return &MockRepositoryWorktreeCall{Call: call}
}

// MockRepositoryWorktreeCall wrap *gomock.Call
type MockRepositoryWorktreeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRepositoryWorktreeCall) Return(arg0 *git.Worktree, arg1 error) *MockRepositoryWorktreeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRepositoryWorktreeCall) Do(f func() (*git.Worktree, error)) *MockRepositoryWorktreeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRepositoryWorktreeCall) DoAndReturn(f func() (*git.Worktree, error)) *MockRepositoryWorktreeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
