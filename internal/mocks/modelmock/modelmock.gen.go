// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/act3-ai/gnoci/internal/model (interfaces: ReadOnlyModeler,Modeler)
//
// Generated by this command:
//
//	mockgen -typed -package modelmock -destination ./modelmock.gen.go github.com/act3-ai/gnoci/internal/model ReadOnlyModeler,Modeler
//

// Package modelmock is a generated GoMock package.
package modelmock

import (
	context "context"
	io "io"
	iter "iter"
	reflect "reflect"

	git "github.com/act3-ai/gnoci/internal/git"
	model "github.com/act3-ai/gnoci/internal/model"
	oci "github.com/act3-ai/gnoci/pkg/oci"
	plumbing "github.com/go-git/go-git/v5/plumbing"
	object "github.com/go-git/go-git/v5/plumbing/object"
	digest "github.com/opencontainers/go-digest"
	v1 "github.com/opencontainers/image-spec/specs-go/v1"
	gomock "go.uber.org/mock/gomock"
	registry "oras.land/oras-go/v2/registry"
)

// MockReadOnlyModeler is a mock of ReadOnlyModeler interface.
type MockReadOnlyModeler struct {
	ctrl     *gomock.Controller
	recorder *MockReadOnlyModelerMockRecorder
	isgomock struct{}
}

// MockReadOnlyModelerMockRecorder is the mock recorder for MockReadOnlyModeler.
type MockReadOnlyModelerMockRecorder struct {
	mock *MockReadOnlyModeler
}

// NewMockReadOnlyModeler creates a new mock instance.
func NewMockReadOnlyModeler(ctrl *gomock.Controller) *MockReadOnlyModeler {
	mock := &MockReadOnlyModeler{ctrl: ctrl}
	mock.recorder = &MockReadOnlyModelerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockReadOnlyModeler) EXPECT() *MockReadOnlyModelerMockRecorder {
	return m.recorder
}

// CommitExists mocks base method.
func (m *MockReadOnlyModeler) CommitExists(localRepo git.Repository, commit *object.Commit) (digest.Digest, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CommitExists", localRepo, commit)
	ret0, _ := ret[0].(digest.Digest)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CommitExists indicates an expected call of CommitExists.
func (mr *MockReadOnlyModelerMockRecorder) CommitExists(localRepo, commit any) *MockReadOnlyModelerCommitExistsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CommitExists", reflect.TypeOf((*MockReadOnlyModeler)(nil).CommitExists), localRepo, commit)
	return &MockReadOnlyModelerCommitExistsCall{Call: call}
}

// MockReadOnlyModelerCommitExistsCall wrap *gomock.Call
type MockReadOnlyModelerCommitExistsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockReadOnlyModelerCommitExistsCall) Return(arg0 digest.Digest, arg1 error) *MockReadOnlyModelerCommitExistsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockReadOnlyModelerCommitExistsCall) Do(f func(git.Repository, *object.Commit) (digest.Digest, error)) *MockReadOnlyModelerCommitExistsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockReadOnlyModelerCommitExistsCall) DoAndReturn(f func(git.Repository, *object.Commit) (digest.Digest, error)) *MockReadOnlyModelerCommitExistsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Fetch mocks base method.
func (m *MockReadOnlyModeler) Fetch(ctx context.Context) (v1.Descriptor, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Fetch", ctx)
	ret0, _ := ret[0].(v1.Descriptor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Fetch indicates an expected call of Fetch.
func (mr *MockReadOnlyModelerMockRecorder) Fetch(ctx any) *MockReadOnlyModelerFetchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fetch", reflect.TypeOf((*MockReadOnlyModeler)(nil).Fetch), ctx)
	return &MockReadOnlyModelerFetchCall{Call: call}
}

// MockReadOnlyModelerFetchCall wrap *gomock.Call
type MockReadOnlyModelerFetchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockReadOnlyModelerFetchCall) Return(arg0 v1.Descriptor, arg1 error) *MockReadOnlyModelerFetchCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockReadOnlyModelerFetchCall) Do(f func(context.Context) (v1.Descriptor, error)) *MockReadOnlyModelerFetchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockReadOnlyModelerFetchCall) DoAndReturn(f func(context.Context) (v1.Descriptor, error)) *MockReadOnlyModelerFetchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FetchLayer mocks base method.
func (m *MockReadOnlyModeler) FetchLayer(ctx context.Context, dgst digest.Digest) (io.ReadCloser, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchLayer", ctx, dgst)
	ret0, _ := ret[0].(io.ReadCloser)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchLayer indicates an expected call of FetchLayer.
func (mr *MockReadOnlyModelerMockRecorder) FetchLayer(ctx, dgst any) *MockReadOnlyModelerFetchLayerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchLayer", reflect.TypeOf((*MockReadOnlyModeler)(nil).FetchLayer), ctx, dgst)
	return &MockReadOnlyModelerFetchLayerCall{Call: call}
}

// MockReadOnlyModelerFetchLayerCall wrap *gomock.Call
type MockReadOnlyModelerFetchLayerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockReadOnlyModelerFetchLayerCall) Return(arg0 io.ReadCloser, arg1 error) *MockReadOnlyModelerFetchLayerCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockReadOnlyModelerFetchLayerCall) Do(f func(context.Context, digest.Digest) (io.ReadCloser, error)) *MockReadOnlyModelerFetchLayerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockReadOnlyModelerFetchLayerCall) DoAndReturn(f func(context.Context, digest.Digest) (io.ReadCloser, error)) *MockReadOnlyModelerFetchLayerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FetchLayersReverse mocks base method.
func (m *MockReadOnlyModeler) FetchLayersReverse(ctx context.Context) iter.Seq2[io.ReadCloser, error] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchLayersReverse", ctx)
	ret0, _ := ret[0].(iter.Seq2[io.ReadCloser, error])
	return ret0
}

// FetchLayersReverse indicates an expected call of FetchLayersReverse.
func (mr *MockReadOnlyModelerMockRecorder) FetchLayersReverse(ctx any) *MockReadOnlyModelerFetchLayersReverseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchLayersReverse", reflect.TypeOf((*MockReadOnlyModeler)(nil).FetchLayersReverse), ctx)
	return &MockReadOnlyModelerFetchLayersReverseCall{Call: call}
}

// MockReadOnlyModelerFetchLayersReverseCall wrap *gomock.Call
type MockReadOnlyModelerFetchLayersReverseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockReadOnlyModelerFetchLayersReverseCall) Return(arg0 iter.Seq2[io.ReadCloser, error]) *MockReadOnlyModelerFetchLayersReverseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockReadOnlyModelerFetchLayersReverseCall) Do(f func(context.Context) iter.Seq2[io.ReadCloser, error]) *MockReadOnlyModelerFetchLayersReverseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockReadOnlyModelerFetchLayersReverseCall) DoAndReturn(f func(context.Context) iter.Seq2[io.ReadCloser, error]) *MockReadOnlyModelerFetchLayersReverseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FetchOrDefault mocks base method.
func (m *MockReadOnlyModeler) FetchOrDefault(ctx context.Context) (v1.Descriptor, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchOrDefault", ctx)
	ret0, _ := ret[0].(v1.Descriptor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchOrDefault indicates an expected call of FetchOrDefault.
func (mr *MockReadOnlyModelerMockRecorder) FetchOrDefault(ctx any) *MockReadOnlyModelerFetchOrDefaultCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchOrDefault", reflect.TypeOf((*MockReadOnlyModeler)(nil).FetchOrDefault), ctx)
	return &MockReadOnlyModelerFetchOrDefaultCall{Call: call}
}

// MockReadOnlyModelerFetchOrDefaultCall wrap *gomock.Call
type MockReadOnlyModelerFetchOrDefaultCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockReadOnlyModelerFetchOrDefaultCall) Return(arg0 v1.Descriptor, arg1 error) *MockReadOnlyModelerFetchOrDefaultCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockReadOnlyModelerFetchOrDefaultCall) Do(f func(context.Context) (v1.Descriptor, error)) *MockReadOnlyModelerFetchOrDefaultCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockReadOnlyModelerFetchOrDefaultCall) DoAndReturn(f func(context.Context) (v1.Descriptor, error)) *MockReadOnlyModelerFetchOrDefaultCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HeadRefs mocks base method.
func (m *MockReadOnlyModeler) HeadRefs() map[plumbing.ReferenceName]oci.ReferenceInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HeadRefs")
	ret0, _ := ret[0].(map[plumbing.ReferenceName]oci.ReferenceInfo)
	return ret0
}

// HeadRefs indicates an expected call of HeadRefs.
func (mr *MockReadOnlyModelerMockRecorder) HeadRefs() *MockReadOnlyModelerHeadRefsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HeadRefs", reflect.TypeOf((*MockReadOnlyModeler)(nil).HeadRefs))
	return &MockReadOnlyModelerHeadRefsCall{Call: call}
}

// MockReadOnlyModelerHeadRefsCall wrap *gomock.Call
type MockReadOnlyModelerHeadRefsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockReadOnlyModelerHeadRefsCall) Return(arg0 map[plumbing.ReferenceName]oci.ReferenceInfo) *MockReadOnlyModelerHeadRefsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockReadOnlyModelerHeadRefsCall) Do(f func() map[plumbing.ReferenceName]oci.ReferenceInfo) *MockReadOnlyModelerHeadRefsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockReadOnlyModelerHeadRefsCall) DoAndReturn(f func() map[plumbing.ReferenceName]oci.ReferenceInfo) *MockReadOnlyModelerHeadRefsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Ref mocks base method.
func (m *MockReadOnlyModeler) Ref() registry.Reference {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ref")
	ret0, _ := ret[0].(registry.Reference)
	return ret0
}

// Ref indicates an expected call of Ref.
func (mr *MockReadOnlyModelerMockRecorder) Ref() *MockReadOnlyModelerRefCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ref", reflect.TypeOf((*MockReadOnlyModeler)(nil).Ref))
	return &MockReadOnlyModelerRefCall{Call: call}
}

// MockReadOnlyModelerRefCall wrap *gomock.Call
type MockReadOnlyModelerRefCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockReadOnlyModelerRefCall) Return(arg0 registry.Reference) *MockReadOnlyModelerRefCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockReadOnlyModelerRefCall) Do(f func() registry.Reference) *MockReadOnlyModelerRefCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockReadOnlyModelerRefCall) DoAndReturn(f func() registry.Reference) *MockReadOnlyModelerRefCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ResolveRef mocks base method.
func (m *MockReadOnlyModeler) ResolveRef(ctx context.Context, refName plumbing.ReferenceName) (*plumbing.Reference, digest.Digest, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResolveRef", ctx, refName)
	ret0, _ := ret[0].(*plumbing.Reference)
	ret1, _ := ret[1].(digest.Digest)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ResolveRef indicates an expected call of ResolveRef.
func (mr *MockReadOnlyModelerMockRecorder) ResolveRef(ctx, refName any) *MockReadOnlyModelerResolveRefCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResolveRef", reflect.TypeOf((*MockReadOnlyModeler)(nil).ResolveRef), ctx, refName)
	return &MockReadOnlyModelerResolveRefCall{Call: call}
}

// MockReadOnlyModelerResolveRefCall wrap *gomock.Call
type MockReadOnlyModelerResolveRefCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockReadOnlyModelerResolveRefCall) Return(arg0 *plumbing.Reference, arg1 digest.Digest, arg2 error) *MockReadOnlyModelerResolveRefCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockReadOnlyModelerResolveRefCall) Do(f func(context.Context, plumbing.ReferenceName) (*plumbing.Reference, digest.Digest, error)) *MockReadOnlyModelerResolveRefCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockReadOnlyModelerResolveRefCall) DoAndReturn(f func(context.Context, plumbing.ReferenceName) (*plumbing.Reference, digest.Digest, error)) *MockReadOnlyModelerResolveRefCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TagRefs mocks base method.
func (m *MockReadOnlyModeler) TagRefs() map[plumbing.ReferenceName]oci.ReferenceInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TagRefs")
	ret0, _ := ret[0].(map[plumbing.ReferenceName]oci.ReferenceInfo)
	return ret0
}

// TagRefs indicates an expected call of TagRefs.
func (mr *MockReadOnlyModelerMockRecorder) TagRefs() *MockReadOnlyModelerTagRefsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TagRefs", reflect.TypeOf((*MockReadOnlyModeler)(nil).TagRefs))
	return &MockReadOnlyModelerTagRefsCall{Call: call}
}

// MockReadOnlyModelerTagRefsCall wrap *gomock.Call
type MockReadOnlyModelerTagRefsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockReadOnlyModelerTagRefsCall) Return(arg0 map[plumbing.ReferenceName]oci.ReferenceInfo) *MockReadOnlyModelerTagRefsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockReadOnlyModelerTagRefsCall) Do(f func() map[plumbing.ReferenceName]oci.ReferenceInfo) *MockReadOnlyModelerTagRefsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockReadOnlyModelerTagRefsCall) DoAndReturn(f func() map[plumbing.ReferenceName]oci.ReferenceInfo) *MockReadOnlyModelerTagRefsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockModeler is a mock of Modeler interface.
type MockModeler struct {
	ctrl     *gomock.Controller
	recorder *MockModelerMockRecorder
	isgomock struct{}
}

// MockModelerMockRecorder is the mock recorder for MockModeler.
type MockModelerMockRecorder struct {
	mock *MockModeler
}

// NewMockModeler creates a new mock instance.
func NewMockModeler(ctrl *gomock.Controller) *MockModeler {
	mock := &MockModeler{ctrl: ctrl}
	mock.recorder = &MockModelerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockModeler) EXPECT() *MockModelerMockRecorder {
	return m.recorder
}

// AddPack mocks base method.
func (m *MockModeler) AddPack(ctx context.Context, path string, refs ...*plumbing.Reference) (v1.Descriptor, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, path}
	for _, a := range refs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddPack", varargs...)
	ret0, _ := ret[0].(v1.Descriptor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddPack indicates an expected call of AddPack.
func (mr *MockModelerMockRecorder) AddPack(ctx, path any, refs ...any) *MockModelerAddPackCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, path}, refs...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPack", reflect.TypeOf((*MockModeler)(nil).AddPack), varargs...)
	return &MockModelerAddPackCall{Call: call}
}

// MockModelerAddPackCall wrap *gomock.Call
type MockModelerAddPackCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelerAddPackCall) Return(arg0 v1.Descriptor, arg1 error) *MockModelerAddPackCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelerAddPackCall) Do(f func(context.Context, string, ...*plumbing.Reference) (v1.Descriptor, error)) *MockModelerAddPackCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelerAddPackCall) DoAndReturn(f func(context.Context, string, ...*plumbing.Reference) (v1.Descriptor, error)) *MockModelerAddPackCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CommitExists mocks base method.
func (m *MockModeler) CommitExists(localRepo git.Repository, commit *object.Commit) (digest.Digest, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CommitExists", localRepo, commit)
	ret0, _ := ret[0].(digest.Digest)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CommitExists indicates an expected call of CommitExists.
func (mr *MockModelerMockRecorder) CommitExists(localRepo, commit any) *MockModelerCommitExistsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CommitExists", reflect.TypeOf((*MockModeler)(nil).CommitExists), localRepo, commit)
	return &MockModelerCommitExistsCall{Call: call}
}

// MockModelerCommitExistsCall wrap *gomock.Call
type MockModelerCommitExistsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelerCommitExistsCall) Return(arg0 digest.Digest, arg1 error) *MockModelerCommitExistsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelerCommitExistsCall) Do(f func(git.Repository, *object.Commit) (digest.Digest, error)) *MockModelerCommitExistsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelerCommitExistsCall) DoAndReturn(f func(git.Repository, *object.Commit) (digest.Digest, error)) *MockModelerCommitExistsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteRef mocks base method.
func (m *MockModeler) DeleteRef(ctx context.Context, refName plumbing.ReferenceName) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteRef", ctx, refName)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteRef indicates an expected call of DeleteRef.
func (mr *MockModelerMockRecorder) DeleteRef(ctx, refName any) *MockModelerDeleteRefCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteRef", reflect.TypeOf((*MockModeler)(nil).DeleteRef), ctx, refName)
	return &MockModelerDeleteRefCall{Call: call}
}

// MockModelerDeleteRefCall wrap *gomock.Call
type MockModelerDeleteRefCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelerDeleteRefCall) Return(arg0 error) *MockModelerDeleteRefCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelerDeleteRefCall) Do(f func(context.Context, plumbing.ReferenceName) error) *MockModelerDeleteRefCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelerDeleteRefCall) DoAndReturn(f func(context.Context, plumbing.ReferenceName) error) *MockModelerDeleteRefCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Fetch mocks base method.
func (m *MockModeler) Fetch(ctx context.Context) (v1.Descriptor, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Fetch", ctx)
	ret0, _ := ret[0].(v1.Descriptor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Fetch indicates an expected call of Fetch.
func (mr *MockModelerMockRecorder) Fetch(ctx any) *MockModelerFetchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Fetch", reflect.TypeOf((*MockModeler)(nil).Fetch), ctx)
	return &MockModelerFetchCall{Call: call}
}

// MockModelerFetchCall wrap *gomock.Call
type MockModelerFetchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelerFetchCall) Return(arg0 v1.Descriptor, arg1 error) *MockModelerFetchCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelerFetchCall) Do(f func(context.Context) (v1.Descriptor, error)) *MockModelerFetchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelerFetchCall) DoAndReturn(f func(context.Context) (v1.Descriptor, error)) *MockModelerFetchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FetchLayer mocks base method.
func (m *MockModeler) FetchLayer(ctx context.Context, dgst digest.Digest) (io.ReadCloser, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchLayer", ctx, dgst)
	ret0, _ := ret[0].(io.ReadCloser)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchLayer indicates an expected call of FetchLayer.
func (mr *MockModelerMockRecorder) FetchLayer(ctx, dgst any) *MockModelerFetchLayerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchLayer", reflect.TypeOf((*MockModeler)(nil).FetchLayer), ctx, dgst)
	return &MockModelerFetchLayerCall{Call: call}
}

// MockModelerFetchLayerCall wrap *gomock.Call
type MockModelerFetchLayerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelerFetchLayerCall) Return(arg0 io.ReadCloser, arg1 error) *MockModelerFetchLayerCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelerFetchLayerCall) Do(f func(context.Context, digest.Digest) (io.ReadCloser, error)) *MockModelerFetchLayerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelerFetchLayerCall) DoAndReturn(f func(context.Context, digest.Digest) (io.ReadCloser, error)) *MockModelerFetchLayerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FetchLayersReverse mocks base method.
func (m *MockModeler) FetchLayersReverse(ctx context.Context) iter.Seq2[io.ReadCloser, error] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchLayersReverse", ctx)
	ret0, _ := ret[0].(iter.Seq2[io.ReadCloser, error])
	return ret0
}

// FetchLayersReverse indicates an expected call of FetchLayersReverse.
func (mr *MockModelerMockRecorder) FetchLayersReverse(ctx any) *MockModelerFetchLayersReverseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchLayersReverse", reflect.TypeOf((*MockModeler)(nil).FetchLayersReverse), ctx)
	return &MockModelerFetchLayersReverseCall{Call: call}
}

// MockModelerFetchLayersReverseCall wrap *gomock.Call
type MockModelerFetchLayersReverseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelerFetchLayersReverseCall) Return(arg0 iter.Seq2[io.ReadCloser, error]) *MockModelerFetchLayersReverseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelerFetchLayersReverseCall) Do(f func(context.Context) iter.Seq2[io.ReadCloser, error]) *MockModelerFetchLayersReverseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelerFetchLayersReverseCall) DoAndReturn(f func(context.Context) iter.Seq2[io.ReadCloser, error]) *MockModelerFetchLayersReverseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FetchOrDefault mocks base method.
func (m *MockModeler) FetchOrDefault(ctx context.Context) (v1.Descriptor, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchOrDefault", ctx)
	ret0, _ := ret[0].(v1.Descriptor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchOrDefault indicates an expected call of FetchOrDefault.
func (mr *MockModelerMockRecorder) FetchOrDefault(ctx any) *MockModelerFetchOrDefaultCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchOrDefault", reflect.TypeOf((*MockModeler)(nil).FetchOrDefault), ctx)
	return &MockModelerFetchOrDefaultCall{Call: call}
}

// MockModelerFetchOrDefaultCall wrap *gomock.Call
type MockModelerFetchOrDefaultCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelerFetchOrDefaultCall) Return(arg0 v1.Descriptor, arg1 error) *MockModelerFetchOrDefaultCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelerFetchOrDefaultCall) Do(f func(context.Context) (v1.Descriptor, error)) *MockModelerFetchOrDefaultCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelerFetchOrDefaultCall) DoAndReturn(f func(context.Context) (v1.Descriptor, error)) *MockModelerFetchOrDefaultCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HeadRefs mocks base method.
func (m *MockModeler) HeadRefs() map[plumbing.ReferenceName]oci.ReferenceInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HeadRefs")
	ret0, _ := ret[0].(map[plumbing.ReferenceName]oci.ReferenceInfo)
	return ret0
}

// HeadRefs indicates an expected call of HeadRefs.
func (mr *MockModelerMockRecorder) HeadRefs() *MockModelerHeadRefsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HeadRefs", reflect.TypeOf((*MockModeler)(nil).HeadRefs))
	return &MockModelerHeadRefsCall{Call: call}
}

// MockModelerHeadRefsCall wrap *gomock.Call
type MockModelerHeadRefsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelerHeadRefsCall) Return(arg0 map[plumbing.ReferenceName]oci.ReferenceInfo) *MockModelerHeadRefsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelerHeadRefsCall) Do(f func() map[plumbing.ReferenceName]oci.ReferenceInfo) *MockModelerHeadRefsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelerHeadRefsCall) DoAndReturn(f func() map[plumbing.ReferenceName]oci.ReferenceInfo) *MockModelerHeadRefsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Push mocks base method.
func (m *MockModeler) Push(ctx context.Context, referrerUpdates ...model.ReferrerUpdater) (v1.Descriptor, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range referrerUpdates {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Push", varargs...)
	ret0, _ := ret[0].(v1.Descriptor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Push indicates an expected call of Push.
func (mr *MockModelerMockRecorder) Push(ctx any, referrerUpdates ...any) *MockModelerPushCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, referrerUpdates...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Push", reflect.TypeOf((*MockModeler)(nil).Push), varargs...)
	return &MockModelerPushCall{Call: call}
}

// MockModelerPushCall wrap *gomock.Call
type MockModelerPushCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelerPushCall) Return(arg0 v1.Descriptor, arg1 error) *MockModelerPushCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelerPushCall) Do(f func(context.Context, ...model.ReferrerUpdater) (v1.Descriptor, error)) *MockModelerPushCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelerPushCall) DoAndReturn(f func(context.Context, ...model.ReferrerUpdater) (v1.Descriptor, error)) *MockModelerPushCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Ref mocks base method.
func (m *MockModeler) Ref() registry.Reference {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ref")
	ret0, _ := ret[0].(registry.Reference)
	return ret0
}

// Ref indicates an expected call of Ref.
func (mr *MockModelerMockRecorder) Ref() *MockModelerRefCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ref", reflect.TypeOf((*MockModeler)(nil).Ref))
	return &MockModelerRefCall{Call: call}
}

// MockModelerRefCall wrap *gomock.Call
type MockModelerRefCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelerRefCall) Return(arg0 registry.Reference) *MockModelerRefCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelerRefCall) Do(f func() registry.Reference) *MockModelerRefCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelerRefCall) DoAndReturn(f func() registry.Reference) *MockModelerRefCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ResolveRef mocks base method.
func (m *MockModeler) ResolveRef(ctx context.Context, refName plumbing.ReferenceName) (*plumbing.Reference, digest.Digest, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResolveRef", ctx, refName)
	ret0, _ := ret[0].(*plumbing.Reference)
	ret1, _ := ret[1].(digest.Digest)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ResolveRef indicates an expected call of ResolveRef.
func (mr *MockModelerMockRecorder) ResolveRef(ctx, refName any) *MockModelerResolveRefCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResolveRef", reflect.TypeOf((*MockModeler)(nil).ResolveRef), ctx, refName)
	return &MockModelerResolveRefCall{Call: call}
}

// MockModelerResolveRefCall wrap *gomock.Call
type MockModelerResolveRefCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelerResolveRefCall) Return(arg0 *plumbing.Reference, arg1 digest.Digest, arg2 error) *MockModelerResolveRefCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelerResolveRefCall) Do(f func(context.Context, plumbing.ReferenceName) (*plumbing.Reference, digest.Digest, error)) *MockModelerResolveRefCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelerResolveRefCall) DoAndReturn(f func(context.Context, plumbing.ReferenceName) (*plumbing.Reference, digest.Digest, error)) *MockModelerResolveRefCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TagRefs mocks base method.
func (m *MockModeler) TagRefs() map[plumbing.ReferenceName]oci.ReferenceInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TagRefs")
	ret0, _ := ret[0].(map[plumbing.ReferenceName]oci.ReferenceInfo)
	return ret0
}

// TagRefs indicates an expected call of TagRefs.
func (mr *MockModelerMockRecorder) TagRefs() *MockModelerTagRefsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TagRefs", reflect.TypeOf((*MockModeler)(nil).TagRefs))
	return &MockModelerTagRefsCall{Call: call}
}

// MockModelerTagRefsCall wrap *gomock.Call
type MockModelerTagRefsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelerTagRefsCall) Return(arg0 map[plumbing.ReferenceName]oci.ReferenceInfo) *MockModelerTagRefsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelerTagRefsCall) Do(f func() map[plumbing.ReferenceName]oci.ReferenceInfo) *MockModelerTagRefsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelerTagRefsCall) DoAndReturn(f func() map[plumbing.ReferenceName]oci.ReferenceInfo) *MockModelerTagRefsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateRef mocks base method.
func (m *MockModeler) UpdateRef(ctx context.Context, ref *plumbing.Reference, ociLayer digest.Digest) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateRef", ctx, ref, ociLayer)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateRef indicates an expected call of UpdateRef.
func (mr *MockModelerMockRecorder) UpdateRef(ctx, ref, ociLayer any) *MockModelerUpdateRefCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateRef", reflect.TypeOf((*MockModeler)(nil).UpdateRef), ctx, ref, ociLayer)
	return &MockModelerUpdateRefCall{Call: call}
}

// MockModelerUpdateRefCall wrap *gomock.Call
type MockModelerUpdateRefCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockModelerUpdateRefCall) Return(arg0 error) *MockModelerUpdateRefCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockModelerUpdateRefCall) Do(f func(context.Context, *plumbing.Reference, digest.Digest) error) *MockModelerUpdateRefCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockModelerUpdateRefCall) DoAndReturn(f func(context.Context, *plumbing.Reference, digest.Digest) error) *MockModelerUpdateRefCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
